2021/7/24

<h3 style='color:green'>
    函数定义和调用：
</h3>
1.两种定义方式

```javascript
function abs(x) {
    if (x >= 0) {
        return x;
    } else {
        return -x;
    }
}

//末尾加;表示赋值语句结束
var abs = function (x) {
    if (x >= 0) {
        return x;
    } else {
        return -x;
    }
};
```

2.函数也是对象。传入参数可多可少。

3.arguments——只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。

4.函数体内部的语句在执行时，一旦执行到`return`时，函数就执行完毕，并将结果返回。

5.rest参数

6.return后会自动填充`;`，用以下方法来涵盖多行语句。

```javascript
return {
	...
};
```



2021/8/1

<h3 style='color:green'>
    变量作用域与解构赋值：
</h3>

1.变量在函数体内部申明，则该变量的作用域为整个函数体，在函数体外不可引用该变量

2.不同函数内部的同名变量互相独立，互不影响

3.JavaScript的函数可以嵌套，此时，内部函数可以访问外部函数定义的变量，反过来则不行

4.JavaScript的函数在查找变量时从自身函数定义开始，从“内”向“外”查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量。

5.JavaScript引擎会自动提升变量的声明，但不会提升变量的赋值。因此在函数内部首先申明所有变量。

```javascript
var
 	x = 1, // x初始化为1
 	y = x + 1, // y初始化为2
    z, i; // z和i为undefined
```

6.不在任何函数内定义的变量就具有全局作用域。实际上，JavaScript默认有一个全局对象`window`，全局作用域的变量实际上被绑定到`window`的一个属性

7.以变量方式`var foo = function () {}`定义的函数实际上也是一个全局变量。因此，顶层函数的定义也被视为一个全局变量，并绑定到`window`对象。（两种定义方式相等）

8.JavaScript实际上只有一个全局作用域

9.减少命名冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中

```javascript
// 唯一的全局变量MYAPP:
var MYAPP = {};

// 其他变量:
MYAPP.name = 'myapp';
MYAPP.version = 1.0;

// 其他函数:
MYAPP.foo = function () {
    return 'foo';
};
```

==变量定义需要var,若没有var默认为window对象的一个属性。直接使用`.`操作符可以为对象添加属性。==

10.使用var 声明的变量是局部变量，不使用var 直接写变量名是全局变量。然后代码中一实验，发现效果确实是符合预期的，但是这个认知却是不正确的，其只是window 对象的一个属性，而不是变量

11.var 定义的变量，作用域是函数内部。let 定义的变量，作用域是块级的，比var作用域小，出了块则不起作用。

12.const 定义常量，块级作用域，出了块无法进行修改。

```javascript
const PI = 3.14;
PI = 3; // 某些浏览器不报错，但是无效果！
PI; // 3.14
```

13.==解构赋值==，同时对一组变量进行赋值。对==数组==元素进行解构赋值时，多个变量要用`[...]`括起来。解构赋值还可以忽略某些元素：

```javascript
let [x, [y, z]] = ['hello', ['JavaScript', 'ES6']];
x; // 'hello'
y; // 'JavaScript'
z; // 'ES6'

let [, , z] = ['hello', 'JavaScript', 'ES6']; // 忽略前两个元素，只对z赋值第三个元素
z; // 'ES6'
```

从一个对象中取出若干属性。

```javascript
var person = {
    name: '小明',
    age: 20,
    gender: 'male',
    passport: 'G-12345678',
    school: 'No.4 middle school'
    address: {
        city: 'Beijing',
        street: 'No.1 Road',
        zipcode: '100001'
    }
};

var {name, age, passport} = person;
// name, age, passport分别被赋值为对应属性:
console.log('name = ' + name + ', age = ' + age + ', passport = ' + passport);

var {name, address: {city, zip}} = person;
// 注意: address不是变量，而是为了让city和zip获得嵌套的address对象的属性:
```

如果要使用的变量名和属性名不一致

```javascript
let {name, passport:id} = person;
name; // '小明'
id; // 'G-12345678'
// 注意: passport不是变量，而是为了让变量id获得passport属性:
```

14.使用解构赋值对对象属性进行赋值时，如果对应的属性不存在，变量将被赋值为`undefined`，这和引用一个不存在的属性获得`undefined`一致。

解构赋值还可以使用默认值，这样就避免了不存在的属性返回`undefined`的问题：

```javascript
var {name, single=true} = person;
name; // '小明'
single; // true
```

15.若先申明，后赋值，需要添加（）；

```javascript
var x, y;
({x, y} = { name: '小明', x: 100, y: 200});
```

16.使用场景:

交换两个变量的值；获取对象的属性并改名；函数参数使用变量来获取对象属性。函数参数可多可少

17.若是数组，用[]，若是对象用{}

```javascript
var [x, y, z] = ['hello', 'JavaScript', 'ES6'];
var {name, age, passport} = person;
```

18.若对象中没有该属性，或数组中没有该元素，可给予默认赋值。

```javascript
var {name, single=true} = person;

var [r = 0, pi = 3.14] = arguments;
```

19.不能使用数组下标来作为解构数组的变量。



2021/8/2

<h3 style='color:green'>
    对象的方法、this指向问题、apply()：
</h3>

1.对象中绑定函数，称为对象的方法。关于this的指向问题。

未被调用；被一个对象调用；被多个对象调用；被执行；

2.对象的方法中再绑定函数（即对象中有函数，函数中还有函数），this重新指向全局对象。用==that==来确定this的指向。

3.Strict模式下和构造函数下this的指向。（非Strict下，==null和undefined==会自动替换为指向全局对象。全局对象指window。）构造函数下，指向新的实例对象。

4.return对this指向的影响。

5.==apply==：用来控制this指向，是==函数本身的方法==。该方法有两个参数。

**第一个参数**：this指向的对象。

非Strict下，null和undefined会自动替换为指向全局对象。

**第二个参数**：一个数组，表示函数本身的参数。

其中的数组元素将作为单独的参数传给函数，若为 null 或 undefined，表示不需要传入任何参数到函数中。

**没有传递参数**：函数中的this指向的是全局变量。

```javascript
function getAge() {
    var y = new Date().getFullYear();
    return y - this.birth;
}

var xiaoming = {
    name: '小明',
    birth: 1990,
    age: getAge
};

xiaoming.age(); // 25
getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空
```

6.==call==：与apply类似。区别：

`apply()`：接受的是一个参数数组。把参数打包成`Array`再传入；

`call()`：接受的是参数列表。把参数按顺序传入。

```javascript
//比如调用Math.max(3, 5, 4)
Math.max.apply(null, [3, 5, 4]); // 5
Math.max.call(null, 3, 5, 4); // 5
```

对普通函数调用，我们通常把`this`绑定为`null`。那就是指向全局对象，因为一般的函数调用（`abs();`）都是全局变量。

7.==window.onload = function() {...}==

相当于在window对象下声明了一个函数function，而要函数执行，你肯定要去调用它，点击(onload)只是调用它的一种方式.

将onload换为parseInt，意为只有当执行parseInt函数（数据类型转换操作执行后），才能调用函数function。

```javascript
//想统计代码一共调用了多少次parseInt()，可以把所有的调用都找出来，然后手动加上count += 1，不过这样做太傻了。最佳方案是用我们自己的函数替换掉默认的parseInt()

var count = 0;
var oldParseInt = parseInt; // 1.保存原函数，将原函数存在新函数中

window.parseInt = function () {
    count += 1;
    return oldParseInt.apply(null, arguments); // （调用原函数。）3.1新函数等于原函数；3.2再将传入原函数的参数以数组的形式存放，并将数组元素作为单独的参数传到到新函数中；3.3返回新函数；3.4则新函数就等同于带有传入参数的原函数。（3.4和第一句可忽略）
};

//2.当执行parseInt函数时，function函数才被调用执行。
parseInt('10');
parseInt('20');
parseInt('30');
console.log('count = ' + count); // 3
```

8.装饰器的作用简单的说就是可以在不修改源码的基础上实现功能的扩展。



2021/8/3

<h3 style='color:green'>
    高阶函数：
</h3>

<h4 style='color:orange'>
    一、map和reduce：
</h4>

1.`map()`方法定义在JavaScript的`Array`中，通过调用`Array`的`map()`方法，传入我们自己的函数，就得到了一个新的`Array`作为结果。	

==把自定义的函数作用在`Array`的每一个元素，并把结果生成一个新的Array==

==map()==传入的==参数==是函数对象本身。从而实现运算规则抽象化。

```javascript
//有一个函数f(x)=x2，要把这个函数作用在一个数组[1, 2, 3, 4, 5, 6, 7, 8, 9]上

function pow(x) {
    return x * x;
}
var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
var results = arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81]
console.log(results);

```

```javascript
//把Array的所有数字转为字符串：

var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
arr.map(String); // ['1', '2', '3', '4', '5', '6', '7', '8', '9']
```

2.==函数必须要有返回值。==

3.==reduce==只可以累乘或累积，是单个元素的求和/求积。

第一个参数是单个元素的累乘/累积；

第二个参数是下一个单个元素。

4.arr.map(Number);可用

5.reduce例题

```javascript
//1.利用reduce()求积
function product(arr) {
    //product乘积；multiply相乘
    function multiply(product, nextElement) {
        console.log(product + ' ' + nextElement);
        return product * nextElement;
    }
    var w = arr.reduce(multiply);
    console.log(w);
    return w;
}
product([1, 2, 3, 4]);
product([0, 1, 2]);
product([99, 88, 77, 66]);

//2.把字符串13579变成Array——[1, 3, 5, 7, 9]，再将array转换成number整数。不使用JavaScript内置的parseInt()函数
function string2int(s) {
    var arr = [];
  //把字符串中的字符放入数组中
  for(var c of s){
    arr.push(c);
  }  

  console.log(arr);
  //字符转成数值
  //ASCII码，数字字符的ASCII码 - '0'的ASCII码值 = 数字字符的数值
  //可以换成var brr = arr.map(Number);
  var brr = arr.map(function(x){
    return x-'0';
  })
  console.log(brr);

  //数组转成整数
  var c = brr.reduce(function(x, y) {
    return x * 10 + y;
  });
  console.log(c);
  return c;
}
string2int('0');
string2int('12345');
string2int('12300');

方法二：
return s.split('').map((x) => x*1).reduce((x, y)=>x * 10 + y);

//3.把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字
function normalize(arr) {
    var brr = arr.map(function(x){
        return x[0].toUpperCase() + x.substring(1).toLowerCase();
    });
    return brr;
}
normalize(['adam', 'LISA', 'barT']);
```

6.split()把字符串分割成字符串数组。



2021/8/5

<h4 style='color:orange'>
    二、filter：
</h4>

